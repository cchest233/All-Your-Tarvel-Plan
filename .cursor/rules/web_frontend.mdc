---
description: When doing frontend work
globs: 
alwaysApply: false
---
# Web Frontend Rules

## Code Style
- Use 2 spaces for indentation
- Maximum line length: 80 characters
- Prefer single quotes for strings
- End statements with semicolons
- Use ES6+ features when available

## Naming Conventions
- Components (React/Vue): PascalCase (e.g., `TravelPlanner`, `DaySchedule`)
- Files:
  - React components: PascalCase with .jsx/.tsx extension (e.g., `TravelPlanner.jsx`)
  - Vue components: PascalCase or kebab-case with .vue extension (e.g., `TravelPlanner.vue` or `travel-planner.vue`)
  - Utility files: camelCase with .js/.ts extension (e.g., `apiClient.js`, `dateUtils.js`)
- Variables and functions: camelCase (e.g., `getUserPreferences()`, `travelDays`)
- Constants: UPPER_SNAKE_CASE (e.g., `API_ENDPOINT`, `DEFAULT_DAYS`)
- CSS classes: kebab-case (e.g., `travel-plan-container`, `day-schedule-card`)
  - If using CSS Modules or CSS-in-JS: camelCase

## Project Structure (React)
```
frontend/
├── public/
├── src/
│   ├── components/
│   │   ├── TravelPlanner.jsx
│   │   ├── DaySchedule.jsx
│   │   └── common/
│   ├── services/
│   │   └── api.js
│   ├── hooks/
│   ├── contexts/
│   ├── utils/
│   ├── assets/
│   ├── styles/
│   ├── App.jsx
│   └── index.js
└── package.json
```

## Component Structure
- Prefer functional components with hooks over class components
- One component per file
- For complex components, divide into smaller subcomponents
- Components should be focused on UI rendering, with business logic in separate hooks or services

## State Management
- Use React Context for simple global state
- Consider Redux, Zustand, or similar for complex applications
- Keep state as local as possible
- Use prop drilling for closely related components
- Prefer controlled components for form elements

## JavaScript/TypeScript Best Practices
- Use const and let instead of var
- Use destructuring for props and state
- Consider using TypeScript for type safety
- Use async/await for asynchronous operations
- Handle errors appropriately in async functions
- Use proper error boundaries

## CSS/Styling
- Consider using CSS-in-JS, CSS Modules, or utility-first frameworks (e.g., Tailwind CSS)
- Use responsive design principles
- Follow mobile-first approach
- Maintain consistent color schemes and spacing units
- Consider accessibility in your designs (color contrast, semantic HTML, etc.)

## Performance Optimization
- Memoize expensive computations using useMemo
- Optimize re-renders with React.memo and useCallback
- Implement code splitting and lazy loading
- Optimize images and assets
- Use performance monitoring tools (Lighthouse, React DevTools)

## Testing
- Use Jest for unit testing
- Use React Testing Library or Enzyme for component testing
- Test component rendering, user interactions, and state changes
- Write meaningful test descriptions
- Aim for good test coverage of critical components

## Tooling
- ESLint for code linting
- Prettier for code formatting
- Consider using Storybook for component development
- Use a build system (Webpack, Vite, etc.) appropriate for the project size

## Accessibility
- Use semantic HTML elements
- Include proper ARIA attributes when necessary
- Ensure keyboard navigation works properly
- Provide alternative text for images
- Maintain sufficient color contrast

